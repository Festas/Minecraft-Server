name: Plugin Install Diagnostics (Comprehensive)

on:
  workflow_dispatch:
    inputs:
      test_plugin_url:
        description: 'Plugin URL to test (leave empty for default test plugin)'
        required: false
        type: string
        default: ''
      skip_cleanup:
        description: 'Skip cleanup (leave test plugin installed)'
        required: false
        type: boolean
        default: false
      run_all_scenarios:
        description: 'Run all test scenarios (valid, missing CSRF, invalid CSRF, etc.)'
        required: false
        type: boolean
        default: true

jobs:
  diagnose-plugin-install:
    runs-on: ubuntu-latest

    permissions:
      contents: read
      actions: write

    env:
      DEPLOY_DIR: /home/deploy/minecraft-server
      CONSOLE_DIR: /home/deploy/minecraft-console
      # Default test plugin - update if this version becomes unavailable
      # Using a small, stable plugin for testing. Can be overridden via test_plugin_url input.
      TEST_PLUGIN_URL: ${{ github.event.inputs.test_plugin_url || 'https://github.com/pl3xgaming/Pl3xMap/releases/download/v1.20.4-477/Pl3xMap-1.20.4-477.jar' }}
      TEST_PLUGIN_NAME: 'Pl3xMap'
      RUN_ALL_SCENARIOS: ${{ github.event.inputs.run_all_scenarios || 'true' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Validate required secrets
        run: |
          MISSING_SECRETS=()

          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            MISSING_SECRETS+=("SSH_PRIVATE_KEY")
          fi
          if [ -z "${{ secrets.SERVER_USER }}" ]; then
            MISSING_SECRETS+=("SERVER_USER")
          fi
          if [ -z "${{ secrets.SERVER_HOST }}" ]; then
            MISSING_SECRETS+=("SERVER_HOST")
          fi
          if [ -z "${{ secrets.CONSOLE_ADMIN_USER }}" ]; then
            MISSING_SECRETS+=("CONSOLE_ADMIN_USER")
          fi
          if [ -z "${{ secrets.CONSOLE_ADMIN_PASSWORD }}" ]; then
            MISSING_SECRETS+=("CONSOLE_ADMIN_PASSWORD")
          fi

          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "::error::Missing required secrets: ${MISSING_SECRETS[*]}"
            echo ""
            echo "Please add the following secrets to your repository:"
            echo "Settings > Secrets and variables > Actions > New repository secret"
            echo ""
            for secret in "${MISSING_SECRETS[@]}"; do
              echo "- $secret"
            done
            exit 1
          fi

          echo "✓ All required secrets are configured"

      - name: Pre-install diagnostics (comprehensive)
        id: pre_install
        run: |
          echo "╔════════════════════════════════════════════════════════════════╗"
          echo "║           PRE-INSTALL COMPREHENSIVE DIAGNOSTICS                ║"
          echo "╚════════════════════════════════════════════════════════════════╝"
          echo ""
          
          # Upload diagnostic scripts to server
          scp -i ~/.ssh/id_rsa \
            scripts/plugin-install-diagnostics-lib.sh \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/tmp/
          
          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            set +e  # Continue on errors to collect all diagnostics
            
            # Source diagnostics library
            source /tmp/plugin-install-diagnostics-lib.sh
            
            # Create diagnostics directory
            DIAG_DIR="/tmp/plugin-install-diagnostics-pre-${{ github.run_number }}"
            mkdir -p "$DIAG_DIR"
            
            log_section "System State Capture"
            capture_system_state "$DIAG_DIR/system-state.txt"
            
            log_section "Environment Variables"
            {
              echo "Relevant environment variables:"
              env | grep -E '^(USER|HOME|PATH|PWD|COOKIE_SECURE|NODE_ENV)' | sort
              echo ""
              echo "Current directory: $(pwd)"
              echo "Disk usage:"
              df -h / /tmp ${{ env.DEPLOY_DIR }} 2>/dev/null || true
            } | tee "$DIAG_DIR/environment.txt"
            
            log_section "Clock and Time Sync"
            {
              echo "System time information:"
              echo "  Local time: $(date)"
              echo "  UTC time: $(date -u)"
              echo "  Timezone: $(timedatectl show --property=Timezone --value 2>/dev/null || echo 'UNKNOWN')"
              echo "  Epoch timestamp: $(date +%s)"
              echo ""
              echo "Clock drift check:"
              # Compare with a reliable time source
              SYSTEM_TIME=$(date +%s)
              echo "  System epoch: $SYSTEM_TIME"
              echo ""
              # Check NTP status if available
              if command -v timedatectl >/dev/null 2>&1; then
                echo "NTP status:"
                timedatectl show --property=NTP --value 2>/dev/null || echo "  Not available"
              fi
            } | tee "$DIAG_DIR/clock-sync.txt"
            
            log_section "File Permissions - plugins.json"
            PLUGINS_JSON="${{ env.DEPLOY_DIR }}/plugins.json"
            test_file_permissions "$PLUGINS_JSON" "$DIAG_DIR/plugins-json-permissions.txt"
            
            log_section "File Permissions - plugins directory"
            PLUGINS_DIR="${{ env.DEPLOY_DIR }}/plugins"
            test_file_permissions "$PLUGINS_DIR" "$DIAG_DIR/plugins-dir-permissions.txt"
            
            log_section "Capture plugins.json state (BEFORE)"
            capture_plugins_json "$PLUGINS_JSON" "$DIAG_DIR/plugins-json-before.txt"
            
            log_section "Capture plugins directory state (BEFORE)"
            capture_plugins_dir "$PLUGINS_DIR" "$DIAG_DIR/plugins-dir-before.txt"
            
            log_section "Docker Container Diagnostics"
            docker_diagnostics "minecraft-console" "$DIAG_DIR/docker-diagnostics.txt"
            
            log_section "Docker Compose Configuration"
            {
              echo "Docker Compose config:"
              cd ${{ env.CONSOLE_DIR }}
              docker compose config 2>&1 || echo "Failed to get compose config"
            } | tee "$DIAG_DIR/docker-compose-config.yml"
            
            log_section "Docker Network Inspection"
            {
              echo "Docker networks:"
              docker network ls
              echo ""
              echo "Container network details:"
              docker inspect minecraft-console 2>/dev/null | jq '.[] | {
                Name: .Name,
                NetworkMode: .HostConfig.NetworkMode,
                Networks: .NetworkSettings.Networks
              }' 2>/dev/null || echo "Failed to inspect networks"
            } | tee "$DIAG_DIR/docker-network.txt"
            
            log_section "Backend API Health Check"
            {
              echo "Testing backend API endpoints:"
              echo ""
              
              echo "1. Health endpoint:"
              curl -v http://localhost:3001/health 2>&1 | tee "$DIAG_DIR/health-check-raw.txt" | head -30
              echo ""
              
              echo "2. Plugins endpoint (unauthenticated):"
              curl -v http://localhost:3001/api/plugins 2>&1 | tee "$DIAG_DIR/plugins-unauth-raw.txt" | head -30
              echo ""
            } | tee "$DIAG_DIR/api-health-check.txt"
            
            log_section "Container Resource Usage"
            {
              echo "Container stats snapshot:"
              docker stats minecraft-console --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}\t{{.BlockIO}}" 2>/dev/null || echo "Stats not available"
              echo ""
              
              echo "Container processes:"
              docker top minecraft-console 2>/dev/null || echo "Process list not available"
            } | tee "$DIAG_DIR/container-resources.txt"
            
            log_section "Backend Logs (last 200 lines)"
            docker logs minecraft-console --tail 200 2>&1 | tee "$DIAG_DIR/backend-logs-pre.txt"
            
            log_section "Check for Debug Logs"
            {
              if docker exec minecraft-console test -f /app/logs/api-debug.log 2>/dev/null; then
                echo "✓ API debug log exists"
                echo "Last 100 lines:"
                docker exec minecraft-console tail -100 /app/logs/api-debug.log 2>/dev/null
              else
                echo "ℹ API debug log not found (may not be enabled)"
              fi
            } | tee "$DIAG_DIR/debug-logs-pre.txt"
            
            log_success "Pre-install diagnostics complete"
            echo "Results saved to: $DIAG_DIR"
            
            # List all diagnostic files created
            echo ""
            echo "Diagnostic files created:"
            find "$DIAG_DIR" -type f -exec ls -lh {} \;
          EOF

      - name: Run comprehensive plugin install test scenarios
        id: test_install
        env:
          ADMIN_USER: ${{ secrets.CONSOLE_ADMIN_USER }}
          ADMIN_PASS: ${{ secrets.CONSOLE_ADMIN_PASSWORD }}
        run: |
          echo "╔════════════════════════════════════════════════════════════════╗"
          echo "║        COMPREHENSIVE PLUGIN INSTALL TEST SCENARIOS             ║"
          echo "╚════════════════════════════════════════════════════════════════╝"
          echo ""
          echo "Test plugin URL: ${{ env.TEST_PLUGIN_URL }}"
          echo "Test plugin name: ${{ env.TEST_PLUGIN_NAME }}"
          echo "Run all scenarios: ${{ env.RUN_ALL_SCENARIOS }}"
          echo ""

          # Validate credentials before proceeding
          if [ -z "$ADMIN_USER" ]; then
            echo "::error::ADMIN_USER is empty or not set. Check CONSOLE_ADMIN_USER secret."
            exit 1
          fi
          if [ -z "$ADMIN_PASS" ]; then
            echo "::error::ADMIN_PASS is empty or not set. Check CONSOLE_ADMIN_PASSWORD secret."
            exit 1
          fi

          # Debug: Print credential lengths for troubleshooting (not actual values)
          echo "Debug: ADMIN_USER length: ${#ADMIN_USER} characters"
          echo "Debug: ADMIN_PASS length: ${#ADMIN_PASS} characters"
          echo ""

          # Upload test scenario script to server
          scp -i ~/.ssh/id_rsa \
            scripts/plugin-install-test-scenarios.sh \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/tmp/

          # Run test scenarios on server
          # Pass credentials to SSH session via environment variables
          # Security Note: Credentials are passed as SSH command arguments, which may appear in
          # process listings (`ps`) during execution. This is acceptable for this use case because:
          # 1. The GitHub Actions runner is an ephemeral, isolated environment
          # 2. Only trusted processes run on the runner during workflow execution
          # 3. The SSH session is short-lived and terminates immediately after use
          # 4. Alternative approaches (SendEnv/AcceptEnv) would require server SSH config changes
          # 5. The target server is trusted and controlled by the repository owner
          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
            ADMIN_USER="$ADMIN_USER" \
            ADMIN_PASS="$ADMIN_PASS" \
            TEST_PLUGIN_URL="${{ env.TEST_PLUGIN_URL }}" \
            API_BASE_URL="http://localhost:3001" \
            RESULTS_DIR="/tmp/plugin-install-test-results-${{ github.run_number }}" \
            RUN_ALL_SCENARIOS="${{ env.RUN_ALL_SCENARIOS }}" \
            bash << 'EOFMAIN'
            set +e  # Continue on errors to collect diagnostics

            # Validate credentials are available in SSH session
            if [ -z "$ADMIN_USER" ] || [ -z "$ADMIN_PASS" ]; then
              echo "::error::Credentials not available in SSH session"
              echo "ADMIN_USER length: ${#ADMIN_USER}"
              echo "ADMIN_PASS length: ${#ADMIN_PASS}"
              exit 1
            fi

            echo "╔════════════════════════════════════════════════════════════════╗"
            echo "║                    RUNNING TEST SCENARIOS                      ║"
            echo "╚════════════════════════════════════════════════════════════════╝"
            echo ""

            # Source the diagnostics library
            source /tmp/plugin-install-diagnostics-lib.sh

            # Wait for backend to be ready
            log_section "Backend Readiness Check"
            echo "Waiting for backend to be ready..."
            for i in {1..20}; do
              if curl -s http://localhost:3001/health > /dev/null 2>&1; then
                log_success "Backend is ready"
                break
              fi
              echo "Waiting... ($i/20)"
              sleep 3
            done
            
            if ! curl -s http://localhost:3001/health > /dev/null 2>&1; then
              log_error "Backend is not responding after 60 seconds"
              exit 1
            fi
            echo ""

            # If run_all_scenarios is true, use the comprehensive test script
            if [ "$RUN_ALL_SCENARIOS" = "true" ]; then
              log_section "Running All Test Scenarios"
              
              # Make script executable
              chmod +x /tmp/plugin-install-test-scenarios.sh
              
              # Run the comprehensive test scenarios
              /tmp/plugin-install-test-scenarios.sh
              
              SCENARIO_EXIT_CODE=$?
              echo "scenario_exit_code=$SCENARIO_EXIT_CODE" > /tmp/scenario-result.txt
              
              if [ $SCENARIO_EXIT_CODE -eq 0 ]; then
                log_success "All test scenarios completed successfully"
                echo "install_success=1" > /tmp/install-result.txt
              else
                log_error "Some test scenarios failed"
                echo "install_success=0" > /tmp/install-result.txt
              fi
            else
              # Run just the basic valid scenario
              log_section "Running Basic Valid Scenario Only"
              
              mkdir -p "$RESULTS_DIR"
              
              COOKIES_FILE="$RESULTS_DIR/cookies.txt"
              SCENARIO_DIR="$RESULTS_DIR/scenario-basic-valid"
              mkdir -p "$SCENARIO_DIR"
              
              INSTALL_SUCCESS=0
              
              # Step 1: Authenticate
              log_subsection "Step 1: Authentication"
              LOGIN_REQUEST=$(jq -n --arg user "$ADMIN_USER" --arg pass "$ADMIN_PASS" \
                '{username: $user, password: $pass}')
              
              echo "$LOGIN_REQUEST" > "$SCENARIO_DIR/login-request.json"
              
              LOGIN_RESPONSE=$(curl -s -c "$COOKIES_FILE" -w "\n%{http_code}" \
                -D "$SCENARIO_DIR/login-response-headers.txt" \
                -X POST http://localhost:3001/api/login \
                -H "Content-Type: application/json" \
                --data-binary @"$SCENARIO_DIR/login-request.json" 2>&1)

              LOGIN_STATUS=$(echo "$LOGIN_RESPONSE" | tail -1)
              LOGIN_BODY=$(echo "$LOGIN_RESPONSE" | sed '$d')

              echo "$LOGIN_STATUS" > "$SCENARIO_DIR/login-status.txt"
              echo "$LOGIN_BODY" > "$SCENARIO_DIR/login-response.json"

              log_info "Login status: $LOGIN_STATUS"
              
              if [ "$LOGIN_STATUS" = "200" ]; then
                log_success "Authentication successful"
                echo "$LOGIN_BODY" | jq '.' 2>/dev/null || echo "$LOGIN_BODY"
                
                # Inspect cookies
                inspect_cookie_jar "$COOKIES_FILE" "$SCENARIO_DIR/post-login-cookies.txt"
              else
                log_error "Authentication failed"
                log_error "Response: $LOGIN_BODY"
                echo "install_success=0" > /tmp/install-result.txt
                exit 1
              fi
              echo ""

              # Step 2: Fetch CSRF token
              log_subsection "Step 2: Fetch CSRF Token"
              CSRF_RESPONSE=$(curl -s -b "$COOKIES_FILE" -c "$COOKIES_FILE" \
                -w "\n%{http_code}" \
                -D "$SCENARIO_DIR/csrf-response-headers.txt" \
                -X GET http://localhost:3001/api/csrf-token 2>&1)

              CSRF_STATUS=$(echo "$CSRF_RESPONSE" | tail -1)
              CSRF_BODY=$(echo "$CSRF_RESPONSE" | sed '$d')

              echo "$CSRF_STATUS" > "$SCENARIO_DIR/csrf-status.txt"
              echo "$CSRF_BODY" > "$SCENARIO_DIR/csrf-response.json"

              log_info "CSRF token endpoint status: $CSRF_STATUS"
              
              if [ "$CSRF_STATUS" = "200" ]; then
                CSRF_TOKEN=$(echo "$CSRF_BODY" | jq -r '.csrfToken' 2>/dev/null)
                if [ -n "$CSRF_TOKEN" ] && [ "$CSRF_TOKEN" != "null" ]; then
                  log_success "CSRF token obtained successfully"
                  log_info "CSRF token length: ${#CSRF_TOKEN} characters"
                  
                  # Validate and inspect CSRF token
                  validate_csrf_token "$SCENARIO_DIR/csrf-response.json" "$COOKIES_FILE" "$SCENARIO_DIR/csrf-validation.txt"
                  
                  # Inspect cookies after CSRF
                  inspect_cookie_jar "$COOKIES_FILE" "$SCENARIO_DIR/post-csrf-cookies.txt"
                else
                  log_error "Failed to parse CSRF token from response"
                  log_error "Response: $CSRF_BODY"
                  echo "install_success=0" > /tmp/install-result.txt
                  exit 1
                fi
              else
                log_error "Failed to fetch CSRF token"
                log_error "Response: $CSRF_BODY"
                echo "install_success=0" > /tmp/install-result.txt
                exit 1
              fi
              echo ""

              # Step 3: Get initial plugin state
              log_subsection "Step 3: Get Initial Plugin State"
              PLUGINS_BEFORE=$(curl -s -b "$COOKIES_FILE" \
                -H "CSRF-Token: $CSRF_TOKEN" \
                -D "$SCENARIO_DIR/plugins-before-headers.txt" \
                http://localhost:3001/api/plugins 2>&1)

              echo "$PLUGINS_BEFORE" > "$SCENARIO_DIR/plugins-before-response.json"
              log_info "Initial plugins response:"
              echo "$PLUGINS_BEFORE" | jq '.' 2>/dev/null || echo "$PLUGINS_BEFORE"

              # Validate API response
              if echo "$PLUGINS_BEFORE" | jq -e '.plugins' > /dev/null 2>&1; then
                log_success "Successfully retrieved plugin list"
              else
                log_warning "Unexpected API response format"
                if echo "$PLUGINS_BEFORE" | grep -qi "csrf\|token"; then
                  log_error "CSRF token may be invalid or rejected"
                  echo "install_success=0" > /tmp/install-result.txt
                  exit 1
                fi
              fi
              echo ""

              # Step 4: Attempt plugin install
              log_subsection "Step 4: Plugin Install"
              
              INSTALL_REQUEST=$(jq -n --arg url "$TEST_PLUGIN_URL" '{url: $url}')
              echo "$INSTALL_REQUEST" > "$SCENARIO_DIR/install-request.json"
              
              INSTALL_RESPONSE=$(curl -s -b "$COOKIES_FILE" -c "$COOKIES_FILE" \
                -w "\n%{http_code}" \
                -D "$SCENARIO_DIR/install-response-headers.txt" \
                -X POST http://localhost:3001/api/plugins/install \
                -H "Content-Type: application/json" \
                -H "CSRF-Token: $CSRF_TOKEN" \
                -d "@$SCENARIO_DIR/install-request.json" 2>&1)

              INSTALL_STATUS=$(echo "$INSTALL_RESPONSE" | tail -1)
              INSTALL_BODY=$(echo "$INSTALL_RESPONSE" | sed '$d')

              echo "$INSTALL_STATUS" > "$SCENARIO_DIR/install-status.txt"
              echo "$INSTALL_BODY" > "$SCENARIO_DIR/install-response.json"

              log_info "Install API status: $INSTALL_STATUS"
              log_info "Response:"
              echo "$INSTALL_BODY" | jq '.' 2>/dev/null || echo "$INSTALL_BODY"
              echo ""
              
              # Inspect cookies after install
              inspect_cookie_jar "$COOKIES_FILE" "$SCENARIO_DIR/post-install-cookies.txt"

              # Check if install was successful
              if [ "$INSTALL_STATUS" = "200" ] || [ "$INSTALL_STATUS" = "201" ]; then
                log_success "Install API returned success status"

                # Check response body
                INSTALL_RESULT_STATUS=$(echo "$INSTALL_BODY" | jq -r '.status' 2>/dev/null || echo "unknown")
                log_info "Install result status: $INSTALL_RESULT_STATUS"

                if [ "$INSTALL_RESULT_STATUS" = "installed" ]; then
                  log_success "Plugin was installed successfully"
                  INSTALL_SUCCESS=1
                elif [ "$INSTALL_RESULT_STATUS" = "conflict" ]; then
                  log_warning "Plugin already exists (conflict detected)"
                  log_info "This is expected on subsequent runs"
                  INSTALL_SUCCESS=1
                else
                  log_warning "Install completed but with unexpected status"
                fi
              else
                log_error "Install API returned error status: $INSTALL_STATUS"

                # Check for specific error types
                if echo "$INSTALL_BODY" | grep -qi "csrf\|token"; then
                  log_error "CSRF token error detected!"
                  log_error "This indicates the CSRF token was invalid or missing."
                  cat "$SCENARIO_DIR/csrf-validation.txt" 2>/dev/null || true
                elif echo "$INSTALL_BODY" | grep -qi "auth"; then
                  log_error "Authentication error detected!"
                  log_error "This indicates the session may have expired or is invalid."
                fi

                if echo "$INSTALL_BODY" | jq -e '.error' > /dev/null 2>&1; then
                  ERROR_MSG=$(echo "$INSTALL_BODY" | jq -r '.error')
                  log_error "Error message: $ERROR_MSG"
                fi
              fi
              echo ""

              # Save result
              echo "install_success=$INSTALL_SUCCESS" > /tmp/install-result.txt
              
              if [ $INSTALL_SUCCESS -eq 1 ]; then
                echo "PASS: Plugin install succeeded" > "$SCENARIO_DIR/scenario-result.txt"
              else
                echo "FAIL: Plugin install failed" > "$SCENARIO_DIR/scenario-result.txt"
              fi
              
              # Generate summary for this scenario
              generate_summary "$RESULTS_DIR" "$RESULTS_DIR/test-summary.txt"
            fi
            
            log_section "Test Scenarios Complete"
          EOFMAIN

          # Check if tests were successful
          INSTALL_SUCCESS=$(ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
            "cat /tmp/install-result.txt 2>/dev/null | grep install_success | cut -d= -f2" || echo "0")

          echo "install_success=$INSTALL_SUCCESS" >> $GITHUB_OUTPUT

          if [ "$INSTALL_SUCCESS" = "1" ]; then
            echo "✓ Plugin install test(s) passed"
          else
            echo "✗ Plugin install test(s) failed"
          fi

      - name: Post-install diagnostics (comprehensive)
        if: always()
        run: |
          echo "╔════════════════════════════════════════════════════════════════╗"
          echo "║          POST-INSTALL COMPREHENSIVE DIAGNOSTICS                ║"
          echo "╚════════════════════════════════════════════════════════════════╝"
          echo ""

          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            set +e  # Continue on errors to collect all diagnostics
            
            # Source diagnostics library
            source /tmp/plugin-install-diagnostics-lib.sh
            
            # Create post-diagnostics directory
            DIAG_DIR="/tmp/plugin-install-diagnostics-post-${{ github.run_number }}"
            mkdir -p "$DIAG_DIR"
            
            log_section "Post-Install State Capture"
            
            log_subsection "Capture plugins.json state (AFTER)"
            PLUGINS_JSON="${{ env.DEPLOY_DIR }}/plugins.json"
            capture_plugins_json "$PLUGINS_JSON" "$DIAG_DIR/plugins-json-after.txt"
            
            log_subsection "Capture plugins directory state (AFTER)"
            PLUGINS_DIR="${{ env.DEPLOY_DIR }}/plugins"
            capture_plugins_dir "$PLUGINS_DIR" "$DIAG_DIR/plugins-dir-after.txt"
            
            log_subsection "Verify test plugin in plugins.json"
            {
              if [ -f "$PLUGINS_JSON" ]; then
                if jq -e ".plugins[] | select(.name == \"${{ env.TEST_PLUGIN_NAME }}\")" "$PLUGINS_JSON" > /dev/null 2>&1; then
                  log_success "Test plugin '${{ env.TEST_PLUGIN_NAME }}' found in plugins.json"
                  jq ".plugins[] | select(.name == \"${{ env.TEST_PLUGIN_NAME }}\")" "$PLUGINS_JSON"
                else
                  log_warning "Test plugin '${{ env.TEST_PLUGIN_NAME }}' not found in plugins.json"
                fi
              else
                log_error "plugins.json does not exist"
              fi
            } | tee "$DIAG_DIR/test-plugin-verification.txt"
            
            log_subsection "Verify test plugin JAR file"
            {
              if [ -d "$PLUGINS_DIR" ]; then
                if ls "$PLUGINS_DIR" 2>/dev/null | grep -i "${{ env.TEST_PLUGIN_NAME }}" > /dev/null; then
                  log_success "Test plugin JAR found in plugins directory:"
                  ls -lh "$PLUGINS_DIR" | grep -i "${{ env.TEST_PLUGIN_NAME }}"
                else
                  log_warning "Test plugin JAR not found in plugins directory"
                  echo "All JAR files in directory:"
                  ls -lh "$PLUGINS_DIR"/*.jar 2>/dev/null || echo "  No JAR files found"
                fi
              else
                log_error "plugins directory does not exist"
              fi
            } | tee "$DIAG_DIR/test-plugin-jar-verification.txt"
            
            log_section "Backend Error Logs"
            
            log_subsection "Install errors log"
            {
              if docker exec minecraft-console test -f /app/data/install-errors.log 2>/dev/null; then
                log_info "install-errors.log exists"
                echo "Full contents:"
                docker exec minecraft-console cat /app/data/install-errors.log 2>/dev/null
              else
                log_info "install-errors.log not found (no errors logged)"
              fi
            } | tee "$DIAG_DIR/install-errors.log"
            
            log_subsection "Plugin history log"
            {
              if docker exec minecraft-console test -f /app/data/plugin-history.json 2>/dev/null; then
                log_info "plugin-history.json exists"
                echo "Full contents:"
                docker exec minecraft-console cat /app/data/plugin-history.json 2>/dev/null | jq '.' 2>/dev/null || cat
              else
                log_info "plugin-history.json not found"
              fi
            } | tee "$DIAG_DIR/plugin-history.json"
            
            log_subsection "Backend logs (last 300 lines)"
            docker logs minecraft-console --tail 300 2>&1 | tee "$DIAG_DIR/backend-logs-post.txt"
            
            log_subsection "API debug logs (full)"
            {
              if docker exec minecraft-console test -f /app/logs/api-debug.log 2>/dev/null; then
                log_info "api-debug.log exists, dumping full log:"
                docker exec minecraft-console cat /app/logs/api-debug.log 2>/dev/null
              else
                log_info "api-debug.log not found"
              fi
            } | tee "$DIAG_DIR/api-debug-full.log"
            
            log_section "State Comparison"
            
            # Compare plugins.json before/after
            if [ -f /tmp/plugin-install-diagnostics-pre-${{ github.run_number }}/plugins-json-before.txt.json ]; then
              log_subsection "plugins.json comparison"
              compare_states \
                "/tmp/plugin-install-diagnostics-pre-${{ github.run_number }}/plugins-json-before.txt.json" \
                "$DIAG_DIR/plugins-json-after.txt.json" \
                "$DIAG_DIR/plugins-json-comparison.txt"
            fi
            
            # Compare plugins directory before/after
            if [ -f /tmp/plugin-install-diagnostics-pre-${{ github.run_number }}/plugins-dir-before.txt ]; then
              log_subsection "plugins directory comparison"
              {
                echo "File differences:"
                diff -u \
                  "/tmp/plugin-install-diagnostics-pre-${{ github.run_number }}/plugins-dir-before.txt" \
                  "$DIAG_DIR/plugins-dir-after.txt" || true
              } | tee "$DIAG_DIR/plugins-dir-comparison.txt"
            fi
            
            log_section "Final System State"
            
            capture_system_state "$DIAG_DIR/system-state-final.txt"
            docker_diagnostics "minecraft-console" "$DIAG_DIR/docker-diagnostics-final.txt"
            
            log_success "Post-install diagnostics complete"
            echo "Results saved to: $DIAG_DIR"
          EOF


      - name: Collect all diagnostic files (comprehensive)
        if: always()
        run: |
          echo "╔════════════════════════════════════════════════════════════════╗"
          echo "║              COLLECTING ALL DIAGNOSTIC FILES                   ║"
          echo "╚════════════════════════════════════════════════════════════════╝"
          echo ""

          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            set +e
            
            # Source diagnostics library
            source /tmp/plugin-install-diagnostics-lib.sh
            
            log_section "Collecting Diagnostic Artifacts"
            
            # Create comprehensive diagnostics package
            PACKAGE_DIR="/tmp/plugin-install-diagnostics-final-${{ github.run_number }}"
            mkdir -p "$PACKAGE_DIR"
            
            log_info "Package directory: $PACKAGE_DIR"
            
            # Copy pre-install diagnostics
            if [ -d "/tmp/plugin-install-diagnostics-pre-${{ github.run_number }}" ]; then
              log_info "Copying pre-install diagnostics..."
              cp -r "/tmp/plugin-install-diagnostics-pre-${{ github.run_number }}" "$PACKAGE_DIR/pre-install/"
            fi
            
            # Copy post-install diagnostics
            if [ -d "/tmp/plugin-install-diagnostics-post-${{ github.run_number }}" ]; then
              log_info "Copying post-install diagnostics..."
              cp -r "/tmp/plugin-install-diagnostics-post-${{ github.run_number }}" "$PACKAGE_DIR/post-install/"
            fi
            
            # Copy test scenario results
            if [ -d "/tmp/plugin-install-test-results-${{ github.run_number }}" ]; then
              log_info "Copying test scenario results..."
              cp -r "/tmp/plugin-install-test-results-${{ github.run_number }}" "$PACKAGE_DIR/test-scenarios/"
            fi
            
            # Generate comprehensive summary
            log_info "Generating comprehensive summary..."
            {
              echo "╔════════════════════════════════════════════════════════════════╗"
              echo "║     Plugin Install Diagnostics - Comprehensive Summary        ║"
              echo "╚════════════════════════════════════════════════════════════════╝"
              echo ""
              echo "Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
              echo "Workflow Run: ${{ github.run_number }}"
              echo "Test Plugin URL: ${{ env.TEST_PLUGIN_URL }}"
              echo "Test Plugin Name: ${{ env.TEST_PLUGIN_NAME }}"
              echo "Run All Scenarios: ${{ env.RUN_ALL_SCENARIOS }}"
              echo ""
              echo "═══════════════════════════════════════════════════════════════"
              echo "DIAGNOSTIC ARTIFACTS COLLECTED"
              echo "═══════════════════════════════════════════════════════════════"
              echo ""
              echo "Pre-Install Diagnostics:"
              echo "  - System state and environment"
              echo "  - File permissions (plugins.json and plugins directory)"
              echo "  - Docker container status and health"
              echo "  - Docker network configuration"
              echo "  - Backend logs and debug logs"
              echo "  - Initial plugins.json and directory state"
              echo ""
              echo "Test Scenarios:"
              if [ "${{ env.RUN_ALL_SCENARIOS }}" = "true" ]; then
                echo "  - Scenario 01: Valid CSRF and session"
                echo "  - Scenario 02: Missing CSRF token"
                echo "  - Scenario 03: Invalid CSRF token"
                echo "  - Scenario 04: Missing session cookie"
                echo "  - Scenario 05: Invalid session cookie"
                echo "  - Scenario 06: Expired session (if feasible)"
              else
                echo "  - Basic valid scenario only"
              fi
              echo ""
              echo "Post-Install Diagnostics:"
              echo "  - Final plugins.json and directory state"
              echo "  - State comparisons (before/after)"
              echo "  - Install error logs"
              echo "  - Plugin history"
              echo "  - Final backend logs and debug logs"
              echo "  - Final Docker container state"
              echo ""
              echo "═══════════════════════════════════════════════════════════════"
              echo "TEST RESULTS SUMMARY"
              echo "═══════════════════════════════════════════════════════════════"
              echo ""
              
              if [ -f "$PACKAGE_DIR/test-scenarios/comprehensive-summary.txt" ]; then
                cat "$PACKAGE_DIR/test-scenarios/comprehensive-summary.txt"
              elif [ -f "$PACKAGE_DIR/test-scenarios/test-summary.txt" ]; then
                cat "$PACKAGE_DIR/test-scenarios/test-summary.txt"
              else
                echo "No test summary available"
              fi
              
              echo ""
              echo "═══════════════════════════════════════════════════════════════"
              echo "DIRECTORY STRUCTURE"
              echo "═══════════════════════════════════════════════════════════════"
              echo ""
              tree -L 3 "$PACKAGE_DIR" 2>/dev/null || find "$PACKAGE_DIR" -type f | head -50
              
              echo ""
              echo "═══════════════════════════════════════════════════════════════"
              echo "FILE INVENTORY"
              echo "═══════════════════════════════════════════════════════════════"
              echo ""
              find "$PACKAGE_DIR" -type f | while read -r file; do
                rel_path=$(realpath --relative-to="$PACKAGE_DIR" "$file")
                size=$(stat -c '%s' "$file" 2>/dev/null || echo "0")
                printf "  %-70s %10s bytes\n" "$rel_path" "$size"
              done
              
              echo ""
              echo "═══════════════════════════════════════════════════════════════"
              echo "DEBUGGING TIPS"
              echo "═══════════════════════════════════════════════════════════════"
              echo ""
              echo "To debug failures:"
              echo "1. Check test-scenarios/scenario-XX-*/scenario-result.txt for test results"
              echo "2. Review test-scenarios/scenario-XX-*/*-response.json for API responses"
              echo "3. Examine test-scenarios/scenario-XX-*/post-*-cookies.txt for cookie state"
              echo "4. Check post-install/install-errors.log for plugin manager errors"
              echo "5. Review post-install/backend-logs-post.txt for server errors"
              echo "6. Compare pre-install/plugins-json-before.txt.json with post-install/plugins-json-after.txt.json"
              echo "7. Check pre-install/plugins-*-permissions.txt for file permission issues"
              echo "8. Review pre-install/docker-diagnostics.txt for container health"
              echo ""
              echo "═══════════════════════════════════════════════════════════════"
              
            } > "$PACKAGE_DIR/COMPREHENSIVE-SUMMARY.txt"
            
            # Create tarball
            log_info "Creating tarball..."
            tar -czf /tmp/plugin-install-diagnostics-final.tar.gz -C /tmp "plugin-install-diagnostics-final-${{ github.run_number }}"
            
            # Show package info
            log_success "Diagnostics package created"
            ls -lh /tmp/plugin-install-diagnostics-final.tar.gz
            
            echo ""
            echo "Package contents:"
            tar -tzf /tmp/plugin-install-diagnostics-final.tar.gz | head -50
          EOF

          # Download diagnostics
          log_info "Downloading diagnostics package..."
          scp -i ~/.ssh/id_rsa \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/tmp/plugin-install-diagnostics-final.tar.gz \
            ./plugin-install-diagnostics.tar.gz

          # Extract for artifact upload
          mkdir -p ./plugin-install-diagnostics
          tar -xzf ./plugin-install-diagnostics.tar.gz -C ./plugin-install-diagnostics --strip-components=1

          echo ""
          echo "✓ Diagnostics downloaded and extracted"
          echo "Total size: $(du -sh ./plugin-install-diagnostics | cut -f1)"
          echo "File count: $(find ./plugin-install-diagnostics -type f | wc -l)"

      - name: Display comprehensive diagnostic summary
        if: always()
        run: |
          echo "=== DIAGNOSTIC FILES SUMMARY ==="

          if [ -d ./plugin-install-diagnostics ]; then
            find ./plugin-install-diagnostics -type f -exec echo "- {}" \; | sed 's|./plugin-install-diagnostics/||'

            echo ""
            echo "=== KEY FILE CONTENTS ==="
            echo ""

            # Show install response
            INSTALL_RESP_FILE=$(find ./plugin-install-diagnostics -name "install-response.json" | head -1)
            if [ -f "$INSTALL_RESP_FILE" ]; then
              echo "## Install API Response:"
              cat "$INSTALL_RESP_FILE" | jq '.' 2>/dev/null || cat "$INSTALL_RESP_FILE"
              echo ""
            fi

            # Show install errors
            INSTALL_ERR_FILE=$(find ./plugin-install-diagnostics -name "install-errors.log" | head -1)
            if [ -f "$INSTALL_ERR_FILE" ]; then
              echo "## Install Errors Log:"
              tail -20 "$INSTALL_ERR_FILE"
              echo ""
            fi
          fi

      - name: Upload diagnostic artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: plugin-install-diagnostics-${{ github.run_number }}
          path: plugin-install-diagnostics/
          retention-days: 30
          if-no-files-found: warn

      - name: Detect and report failures
        if: always()
        run: |
          echo "=== FAILURE DETECTION ==="
          echo ""

          FAILURE_DETECTED=0
          FAILURE_REASONS=()

          # Check if install succeeded
          INSTALL_SUCCESS="${{ steps.test_install.outputs.install_success }}"
          if [ "$INSTALL_SUCCESS" != "1" ]; then
            FAILURE_DETECTED=1
            FAILURE_REASONS+=("Plugin install API returned error or unexpected status")
          fi

          # Check if files were created (download diagnostic files to check)
          if [ -d ./plugin-install-diagnostics ]; then
            # Check if plugins.json was updated
            PLUGINS_BEFORE_FILE=$(find ./plugin-install-diagnostics -name "plugins-before.json" | head -1)
            PLUGINS_AFTER_FILE=$(find ./plugin-install-diagnostics -name "plugins-after.json" | head -1)

            if [ -f "$PLUGINS_BEFORE_FILE" ] && [ -f "$PLUGINS_AFTER_FILE" ]; then
              BEFORE_COUNT=$(jq '.plugins | length' "$PLUGINS_BEFORE_FILE" 2>/dev/null || echo "0")
              AFTER_COUNT=$(jq '.plugins | length' "$PLUGINS_AFTER_FILE" 2>/dev/null || echo "0")

              # Check if plugin was added to plugins.json
              PLUGIN_IN_JSON=$(jq -e ".plugins[] | select(.name == \"${{ env.TEST_PLUGIN_NAME }}\")" "$PLUGINS_AFTER_FILE" > /dev/null 2>&1 && echo "yes" || echo "no")

              if [ "$PLUGIN_IN_JSON" != "yes" ] && [ "$INSTALL_SUCCESS" = "1" ]; then
                FAILURE_DETECTED=1
                FAILURE_REASONS+=("Plugin not found in plugins.json after install")
              fi
            fi

            # Check for permissions errors in install errors log
            INSTALL_ERR_FILE=$(find ./plugin-install-diagnostics -name "install-errors.log" | head -1)
            if [ -f "$INSTALL_ERR_FILE" ]; then
              if grep -qi "permission\|not writable\|EACCES" "$INSTALL_ERR_FILE"; then
                FAILURE_DETECTED=1
                FAILURE_REASONS+=("Permission errors detected in install-errors.log")
              fi
            fi

            # Check backend logs for errors
            BACKEND_LOG_FILE=$(find ./plugin-install-diagnostics -name "backend-logs.txt" | head -1)
            if [ -f "$BACKEND_LOG_FILE" ]; then
              if tail -100 "$BACKEND_LOG_FILE" | grep -qi "error.*plugin\|failed.*install"; then
                FAILURE_DETECTED=1
                FAILURE_REASONS+=("Backend errors detected in container logs")
              fi
            fi
          fi

          # Report results
          if [ $FAILURE_DETECTED -eq 1 ]; then
            echo "::error::Plugin install diagnostics detected failures"
            echo ""
            echo "Failure reasons:"
            for reason in "${FAILURE_REASONS[@]}"; do
              echo "  - $reason"
            done
            echo ""
            echo "Review the uploaded artifacts for detailed diagnostics."
            exit 1
          else
            echo "✓ No critical failures detected"
            echo ""
            echo "Plugin install appears to be working correctly."
          fi

      - name: Cleanup test plugin
        if: success() && github.event.inputs.skip_cleanup != 'true'
        env:
          ADMIN_USER: ${{ secrets.CONSOLE_ADMIN_USER }}
          ADMIN_PASS: ${{ secrets.CONSOLE_ADMIN_PASSWORD }}
        run: |
          echo "=== CLEANING UP TEST PLUGIN ==="
          echo ""

          # Validate credentials before proceeding
          if [ -z "$ADMIN_USER" ] || [ -z "$ADMIN_PASS" ]; then
            echo "::warning::Credentials not available for cleanup. Skipping cleanup."
            exit 0
          fi

          # Pass credentials to SSH session via environment variables
          # (Same security consideration as test install step - acceptable for CI/CD environment)
          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
            ADMIN_USER="$ADMIN_USER" \
            ADMIN_PASS="$ADMIN_PASS" \
            TEST_PLUGIN_NAME="${{ env.TEST_PLUGIN_NAME }}" \
            GITHUB_RUN_NUMBER="${{ github.run_number }}" \
            bash << 'EOF'
            set +e

            # Validate credentials are available in SSH session
            if [ -z "$ADMIN_USER" ] || [ -z "$ADMIN_PASS" ]; then
              echo "::warning::Credentials not available in SSH session. Skipping cleanup."
              exit 0
            fi

            echo "Authenticating for cleanup..."
            LOGIN_RESPONSE=$(jq -n --arg user "$ADMIN_USER" --arg pass "$ADMIN_PASS" \
              '{username: $user, password: $pass}' | \
              curl -s -c /tmp/cookies-cleanup.txt -w "\n%{http_code}" \
              -X POST http://localhost:3001/api/login \
              -H "Content-Type: application/json" \
              --data-binary @- 2>&1)

            LOGIN_STATUS=$(echo "$LOGIN_RESPONSE" | tail -1)

            if [ "$LOGIN_STATUS" = "200" ]; then
              echo "✓ Authenticated"

              # Fetch CSRF token for cleanup operations
              echo "Fetching CSRF token for cleanup..."
              CSRF_RESPONSE=$(curl -s -b /tmp/cookies-cleanup.txt -c /tmp/cookies-cleanup.txt -w "\n%{http_code}" \
                -X GET http://localhost:3001/api/csrf-token 2>&1)

              CSRF_STATUS=$(echo "$CSRF_RESPONSE" | tail -1)
              CSRF_BODY=$(echo "$CSRF_RESPONSE" | sed '$d')

              if [ "$CSRF_STATUS" = "200" ]; then
                CSRF_TOKEN=$(echo "$CSRF_BODY" | jq -r '.csrfToken' 2>/dev/null)
                if [ -n "$CSRF_TOKEN" ] && [ "$CSRF_TOKEN" != "null" ]; then
                  echo "✓ CSRF token obtained for cleanup"
                else
                  echo "⚠ Failed to parse CSRF token, cleanup may fail"
                  CSRF_TOKEN=""
                fi
              else
                echo "⚠ Failed to fetch CSRF token, cleanup may fail"
                CSRF_TOKEN=""
              fi

              # Attempt to uninstall test plugin
              echo "Uninstalling test plugin '$TEST_PLUGIN_NAME'..."

              # Make uninstall request with or without CSRF token
              if [ -n "$CSRF_TOKEN" ]; then
                UNINSTALL_RESPONSE=$(curl -s -b /tmp/cookies-cleanup.txt -w "\n%{http_code}" \
                  -X POST http://localhost:3001/api/plugins/uninstall \
                  -H "Content-Type: application/json" \
                  -H "CSRF-Token: $CSRF_TOKEN" \
                  -d "{\"pluginName\":\"$TEST_PLUGIN_NAME\",\"deleteConfigs\":false}" 2>&1)
              else
                echo "⚠ No CSRF token available, attempting without it (will likely fail)"
                UNINSTALL_RESPONSE=$(curl -s -b /tmp/cookies-cleanup.txt -w "\n%{http_code}" \
                  -X POST http://localhost:3001/api/plugins/uninstall \
                  -H "Content-Type: application/json" \
                  -d "{\"pluginName\":\"$TEST_PLUGIN_NAME\",\"deleteConfigs\":false}" 2>&1)
              fi

              UNINSTALL_STATUS=$(echo "$UNINSTALL_RESPONSE" | tail -1)
              UNINSTALL_BODY=$(echo "$UNINSTALL_RESPONSE" | sed '$d')

              echo "Uninstall status: $UNINSTALL_STATUS"
              echo "Response: $UNINSTALL_BODY"

              if [ "$UNINSTALL_STATUS" = "200" ]; then
                echo "✓ Test plugin uninstalled successfully"
              else
                echo "⚠ Could not uninstall test plugin (may need manual cleanup)"
              fi
            else
              echo "✗ Could not authenticate for cleanup"
            fi

            # Clean up temporary files
            rm -f /tmp/cookies.txt /tmp/cookies-cleanup.txt
            rm -f /tmp/session-cookie-state.txt /tmp/csrf-token-state.json
            rm -f /tmp/plugins-before.json /tmp/plugins-after.json
            rm -f /tmp/api-plugins-before.json /tmp/api-plugins-after.json
            rm -f /tmp/install-response.json /tmp/install-result.txt
            rm -f /tmp/plugins-dir-before.txt /tmp/plugins-dir-after.txt
            rm -rf /tmp/plugin-install-diagnostics-$GITHUB_RUN_NUMBER
            rm -f /tmp/plugin-install-diagnostics.tar.gz

            echo "✓ Temporary files cleaned up"
          EOF

          echo ""
          echo "✓ Cleanup complete"

      - name: Workflow summary
        if: always()
        run: |
          {
            echo "## Plugin Install Diagnostics Summary"
            echo ""
            echo "**Workflow Run:** ${{ github.run_number }}"
            echo "**Test Plugin:** ${{ env.TEST_PLUGIN_NAME }}"
            echo "**Test Plugin URL:** ${{ env.TEST_PLUGIN_URL }}"
            echo ""

            INSTALL_SUCCESS="${{ steps.test_install.outputs.install_success }}"
            if [ "$INSTALL_SUCCESS" = "1" ]; then
              echo "### ✓ Install Test Result: PASSED"
            else
              echo "### ✗ Install Test Result: FAILED"
            fi
            echo ""

            echo "### Diagnostic Artifacts"
            echo "All diagnostic files have been uploaded as workflow artifacts:"
            echo "- \`plugins-before.json\` and \`plugins-after.json\` - Plugin state comparison"
            echo "- \`api-plugins-before.json\` and \`api-plugins-after.json\` - API response comparison"
            echo "- \`install-response.json\` - Install API response"
            echo "- \`install-errors.log\` - Plugin install error log"
            echo "- \`backend-logs.txt\` - Complete backend container logs"
            echo "- \`container-inspect.json\` - Docker container inspection"
            echo "- \`plugins-dir-before.txt\` and \`plugins-dir-after.txt\` - Directory listings"
            echo ""
            echo "Download the artifact to debug plugin install issues without needing browser dev tools."
            echo ""

            echo "### Next Steps"
            if [ "$INSTALL_SUCCESS" = "1" ]; then
              echo "- Plugin install is working correctly"
              echo "- Review artifacts if you need detailed information"
            else
              echo "1. Download the diagnostic artifacts from this workflow run"
              echo "2. Review \`install-response.json\` for API error details"
              echo "3. Check \`install-errors.log\` for plugin manager errors"
              echo "4. Review \`backend-logs.txt\` for server-side issues"
              echo "5. Compare before/after states to identify what changed"
              echo "6. Check permissions on plugins.json and plugins directory"
            fi
          } >> "$GITHUB_STEP_SUMMARY"
