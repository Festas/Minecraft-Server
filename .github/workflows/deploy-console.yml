name: Deploy Console

on:
  push:
    branches:
      - main
    paths:
      - 'console/**'
      - '.github/workflows/deploy-console.yml'
  workflow_dispatch:

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image_sha: ${{ steps.image_sha.outputs.sha }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get short SHA
        id: image_sha
        run: echo "sha=$(git rev-parse --short HEAD)" >> "$GITHUB_OUTPUT"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: image=moby/buildkit:v0.12.5

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./console
          file: ./console/backend/Dockerfile
          push: true
          tags: |
            ghcr.io/festas/minecraft-console:${{ steps.image_sha.outputs.sha }}
            ghcr.io/festas/minecraft-console:latest

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          MISSING_SECRETS=()

          if [ -z "${{ secrets.GHCR_PAT }}" ]; then
            MISSING_SECRETS+=("GHCR_PAT")
          fi
          if [ -z "${{ secrets.CONSOLE_ADMIN_USER }}" ]; then
            MISSING_SECRETS+=("CONSOLE_ADMIN_USER")
          fi
          if [ -z "${{ secrets.CONSOLE_ADMIN_PASSWORD }}" ]; then
            MISSING_SECRETS+=("CONSOLE_ADMIN_PASSWORD")
          fi
          if [ -z "${{ secrets.RCON_PASSWORD }}" ]; then
            MISSING_SECRETS+=("RCON_PASSWORD")
          fi
          if [ -z "${{ secrets.SESSION_SECRET }}" ]; then
            MISSING_SECRETS+=("SESSION_SECRET")
          fi
          if [ -z "${{ secrets.CSRF_SECRET }}" ]; then
            MISSING_SECRETS+=("CSRF_SECRET")
          fi

          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "::error::Missing required secrets: ${MISSING_SECRETS[*]}"
            echo ""
            echo "Please add the following secrets to your repository:"
            echo "Settings > Secrets and variables > Actions > New repository secret"
            echo ""
            for secret in "${MISSING_SECRETS[@]}"; do
              echo "- $secret"
            done
            echo ""
            echo "See CONSOLE-SETUP.md for detailed instructions."
            exit 1
          fi

          echo "âœ“ All required secrets are configured"

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Upload diagnostic scripts
        run: |
          echo "Uploading diagnostic scripts to server..."
          scp -i ~/.ssh/id_rsa scripts/diagnose-plugins.sh \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/home/deploy/minecraft-server/scripts/
          
          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
            "chmod +x /home/deploy/minecraft-server/scripts/diagnose-plugins.sh"

      - name: Pre-deployment diagnostics and auto-fix
        id: pre_deploy_check
        run: |
          echo "Running pre-deployment diagnostics..."
          
          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            cd /home/deploy/minecraft-server
            
            # Run diagnostics in fix mode
            ./scripts/diagnose-plugins.sh fix || true
            
            # Get the latest diagnostics directory
            DIAG_DIR=$(ls -td /tmp/plugin-diagnostics-* 2>/dev/null | head -1)
            
            if [ -n "$DIAG_DIR" ]; then
              # Count issues
              if [ -f "$DIAG_DIR/issues.log" ]; then
                ISSUE_COUNT=$(wc -l < "$DIAG_DIR/issues.log")
                echo "Pre-deployment found $ISSUE_COUNT issues"
              fi
              
              # Check for critical blocking issues
              if [ -f "$DIAG_DIR/manual-actions.log" ]; then
                if grep -qi "port.*missing\|bind.*missing" "$DIAG_DIR/manual-actions.log"; then
                  echo "::warning::Critical port/bind configuration issues detected"
                fi
              fi
            fi
          EOF

      - name: Download pre-deployment diagnostics
        run: |
          echo "Downloading pre-deployment diagnostics..."
          
          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            DIAG_DIR=$(ls -td /tmp/plugin-diagnostics-* 2>/dev/null | head -1)
            if [ -n "$DIAG_DIR" ]; then
              tar -czf /tmp/pre-deploy-diagnostics.tar.gz -C "$(dirname "$DIAG_DIR")" "$(basename "$DIAG_DIR")"
            fi
          EOF
          
          scp -i ~/.ssh/id_rsa \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/tmp/pre-deploy-diagnostics.tar.gz \
            ./pre-deploy-diagnostics.tar.gz || echo "No pre-deploy diagnostics available"
          
          if [ -f ./pre-deploy-diagnostics.tar.gz ]; then
            mkdir -p ./pre-deploy-diagnostics
            tar -xzf ./pre-deploy-diagnostics.tar.gz -C ./pre-deploy-diagnostics
          fi

      - name: Upload pre-deployment diagnostics artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: pre-deployment-diagnostics-${{ github.run_number }}
          path: pre-deploy-diagnostics/
          retention-days: 30
          if-no-files-found: warn

      - name: Validate required secrets
        uses: appleboy/ssh-action@v1.0.3
        env:
          IMAGE_SHA: ${{ needs.build-and-push.outputs.image_sha }}
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          GHCR_ACTOR: ${{ github.actor }}
          CONSOLE_ADMIN_USER: ${{ secrets.CONSOLE_ADMIN_USER }}
          CONSOLE_ADMIN_PASSWORD: ${{ secrets.CONSOLE_ADMIN_PASSWORD }}
          RCON_PASSWORD: ${{ secrets.RCON_PASSWORD }}
          SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
          CSRF_SECRET: ${{ secrets.CSRF_SECRET }}
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          envs: IMAGE_SHA,GHCR_PAT,GHCR_ACTOR,CONSOLE_ADMIN_USER,CONSOLE_ADMIN_PASSWORD,RCON_PASSWORD,SESSION_SECRET,CSRF_SECRET
          script: |
            set -e

            DEPLOY_DIR="/home/deploy/minecraft-console"
            MC_DIR="/home/deploy/minecraft-server"

            mkdir -p "$DEPLOY_DIR"
            cd "$DEPLOY_DIR"

            # Login to GHCR
            echo "$GHCR_PAT" | docker login ghcr.io -u "$GHCR_ACTOR" --password-stdin

            # Pull image
            docker pull "ghcr.io/festas/minecraft-console:${IMAGE_SHA}"

            # Create .env file from secrets (no leading whitespace)
            {
              printf 'ADMIN_USERNAME=%s\n' "${CONSOLE_ADMIN_USER}"
              printf 'ADMIN_PASSWORD=%s\n' "${CONSOLE_ADMIN_PASSWORD}"
              echo 'RCON_HOST=minecraft-server'
              echo 'RCON_PORT=25575'
              printf 'RCON_PASSWORD=%s\n' "${RCON_PASSWORD}"
              printf 'SESSION_SECRET=%s\n' "${SESSION_SECRET}"
              printf 'CSRF_SECRET=%s\n' "${CSRF_SECRET}"
              echo 'CONSOLE_PORT=3001'
              echo 'MC_CONTAINER_NAME=minecraft-server'
              echo 'MC_SERVER_DIR=/minecraft'
              echo 'NODE_ENV=production'
            } > .env
            chmod 600 .env

            # Create docker-compose.yml
            cat > docker-compose.yml <<EOF
            services:
              minecraft-console:
                image: ghcr.io/festas/minecraft-console:${IMAGE_SHA}
                container_name: minecraft-console
                restart: unless-stopped
                ports:
                  - "3001:3001"
                extra_hosts:
                  - "host.docker.internal:host-gateway"
                environment:
                  - API_PORT=3001
                volumes:
                  - ./.env:/app/.env:ro
                  - ${MC_DIR}:/minecraft:rw
                  - /var/run/docker.sock:/var/run/docker.sock
                  - console_data:/app/data
                  - console_config:/app/config
                networks:
                  - caddy-network
                healthcheck:
                  test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3001/health"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
                  start_period: 30s

            volumes:
              console_data:
              console_config:

            networks:
              caddy-network:
                external: true
            EOF

            # Create caddy-network if it doesn't exist
            docker network inspect caddy-network >/dev/null 2>&1 || docker network create caddy-network

            # Deploy
            docker compose up -d

            # Wait for healthy
            for i in {1..30}; do
              HEALTH=$(docker inspect --format='{{.State.Health.Status}}' minecraft-console 2>/dev/null || echo "starting")
              if [ "$HEALTH" = "healthy" ]; then
                echo "âœ“ Console is healthy"
                break
              fi
              sleep 2
            done

            echo "âœ“ Console deployed successfully!"
            echo "URL: https://mc.festas-builds.com/console"

      - name: Test plugin install functionality
        if: success()
        run: |
          echo "Testing plugin install API..."
          
          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            set -e
            
            echo "=== Testing Plugin Install API ==="
            
            # Wait for console to be fully ready
            for i in {1..10}; do
              if curl -s http://localhost:3001/health > /dev/null 2>&1; then
                echo "âœ“ Console is ready"
                break
              fi
              echo "Waiting for console to be ready... ($i/10)"
              sleep 2
            done
            
            # Create test install script
            cat > /tmp/test-plugin-install.sh << 'SCRIPT'
            #!/bin/bash
            set -e
            
            # Test URL - use a small, well-known plugin for testing
            TEST_PLUGIN_URL="https://github.com/pl3xgaming/Pl3xMap/releases/download/v1.20.4-477/Pl3xMap-1.20.4-477.jar"
            
            echo "Testing plugin install with URL: $TEST_PLUGIN_URL"
            
            # Get auth token (login first)
            # Note: This would require proper authentication in production
            # For now, we'll just test the health endpoint and check logs
            
            # Check if install-errors.log exists and is accessible
            BACKEND_DATA_DIR="/home/deploy/minecraft-console"
            if docker exec minecraft-console ls -la /app/data/ 2>/dev/null; then
              echo "âœ“ Backend data directory is accessible"
            fi
            
            # Check console logs for any install errors
            echo "=== Recent console logs ==="
            docker logs minecraft-console --tail 50 2>&1 | grep -i "PLUGIN_INSTALL" || echo "No plugin install logs yet"
            
            # Check if we can access the plugins.json
            if [ -f /home/deploy/minecraft-server/plugins.json ]; then
              echo "âœ“ plugins.json exists and is readable"
              echo "Current plugins count: $(jq '.plugins | length' /home/deploy/minecraft-server/plugins.json 2>/dev/null || echo 'unknown')"
            else
              echo "âš  plugins.json not found at expected location"
            fi
            
            # Check plugins directory permissions
            if [ -d /home/deploy/minecraft-server/plugins ]; then
              echo "âœ“ Plugins directory exists"
              ls -la /home/deploy/minecraft-server/plugins/ | head -5
            else
              echo "âš  Plugins directory not found"
            fi
            
            echo "=== Plugin install test infrastructure verified ==="
            SCRIPT
            
            chmod +x /tmp/test-plugin-install.sh
            /tmp/test-plugin-install.sh
            
            # Collect install-errors.log if it exists
            echo "=== Checking for install-errors.log ==="
            docker exec minecraft-console cat /app/data/install-errors.log 2>/dev/null || echo "No install-errors.log found yet (this is normal if no installs have been attempted)"
          EOF

      - name: Download plugin install logs
        if: always()
        run: |
          echo "Downloading plugin install logs and diagnostics..."
          
          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            # Create a directory for plugin install diagnostics
            mkdir -p /tmp/plugin-install-diagnostics
            
            # Copy install-errors.log if it exists
            docker exec minecraft-console cat /app/data/install-errors.log > /tmp/plugin-install-diagnostics/install-errors.log 2>/dev/null || echo "No install-errors.log found" > /tmp/plugin-install-diagnostics/install-errors.log
            
            # Get recent console logs related to plugin installs
            docker logs minecraft-console --tail 200 2>&1 | grep -i "plugin" > /tmp/plugin-install-diagnostics/console-plugin-logs.txt || echo "No plugin-related logs found"
            
            # Get full recent console logs
            docker logs minecraft-console --tail 500 > /tmp/plugin-install-diagnostics/console-recent.log 2>&1
            
            # Collect backend data directory info
            docker exec minecraft-console ls -laR /app/data/ > /tmp/plugin-install-diagnostics/backend-data-listing.txt 2>/dev/null || echo "Could not list backend data directory"
            
            # Collect plugin-history.json if it exists
            docker exec minecraft-console cat /app/data/plugin-history.json > /tmp/plugin-install-diagnostics/plugin-history.json 2>/dev/null || echo "No plugin history found"
            
            # Create tarball
            tar -czf /tmp/plugin-install-diagnostics.tar.gz -C /tmp plugin-install-diagnostics/
          EOF
          
          # Download the diagnostics
          scp -i ~/.ssh/id_rsa \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/tmp/plugin-install-diagnostics.tar.gz \
            ./plugin-install-diagnostics.tar.gz || echo "No plugin install diagnostics available"
          
          if [ -f ./plugin-install-diagnostics.tar.gz ]; then
            mkdir -p ./plugin-install-diagnostics
            tar -xzf ./plugin-install-diagnostics.tar.gz -C ./plugin-install-diagnostics
            
            # Display install-errors.log if it exists
            if [ -f ./plugin-install-diagnostics/plugin-install-diagnostics/install-errors.log ]; then
              echo "=== install-errors.log content ==="
              cat ./plugin-install-diagnostics/plugin-install-diagnostics/install-errors.log
            fi
          fi

      - name: Upload plugin install diagnostics artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: plugin-install-diagnostics-${{ github.run_number }}
          path: plugin-install-diagnostics/
          retention-days: 30
          if-no-files-found: warn

      - name: Post-deployment diagnostics and auto-fix
        if: success()
        run: |
          echo "Running post-deployment diagnostics..."
          
          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            cd /home/deploy/minecraft-server
            
            # Run diagnostics in fix mode with auto-restart enabled
            AUTO_RESTART=true ./scripts/diagnose-plugins.sh fix || true
            
            # Get the latest diagnostics directory
            DIAG_DIR=$(ls -td /tmp/plugin-diagnostics-* 2>/dev/null | head -1)
            
            if [ -n "$DIAG_DIR" ]; then
              echo "Post-deployment diagnostics completed"
              
              # Display summary
              if [ -f "$DIAG_DIR/deployment-summary.txt" ]; then
                echo "=== Deployment Summary ==="
                cat "$DIAG_DIR/deployment-summary.txt"
              fi
              
              # Check if any issues remain
              if [ -f "$DIAG_DIR/manual-actions.log" ]; then
                MANUAL_COUNT=$(wc -l < "$DIAG_DIR/manual-actions.log")
                if [ "$MANUAL_COUNT" -gt 0 ]; then
                  echo "::warning::$MANUAL_COUNT manual actions still required after deployment"
                fi
              fi
            fi
          EOF

      - name: Download post-deployment diagnostics
        if: success()
        run: |
          echo "Downloading post-deployment diagnostics..."
          
          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            DIAG_DIR=$(ls -td /tmp/plugin-diagnostics-* 2>/dev/null | head -1)
            if [ -n "$DIAG_DIR" ]; then
              tar -czf /tmp/post-deploy-diagnostics.tar.gz -C "$(dirname "$DIAG_DIR")" "$(basename "$DIAG_DIR")"
            fi
          EOF
          
          scp -i ~/.ssh/id_rsa \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/tmp/post-deploy-diagnostics.tar.gz \
            ./post-deploy-diagnostics.tar.gz || echo "No post-deploy diagnostics available"
          
          if [ -f ./post-deploy-diagnostics.tar.gz ]; then
            mkdir -p ./post-deploy-diagnostics
            tar -xzf ./post-deploy-diagnostics.tar.gz -C ./post-deploy-diagnostics
          fi

      - name: Upload post-deployment diagnostics artifact
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: post-deployment-diagnostics-${{ github.run_number }}
          path: post-deploy-diagnostics/
          retention-days: 30
          if-no-files-found: warn

      - name: Handle deployment failure
        if: failure()
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            echo "=== Deployment Failed - Diagnostics ==="
            echo ""
            echo "=== Container Status ==="
            docker ps -a | grep minecraft-console || echo "Container not found"
            echo ""
            echo "=== Container Logs ==="
            docker logs minecraft-console --tail=100 2>&1 || echo "No logs available"
            echo ""
            echo "=== Recent Docker Events ==="
            docker events --since 5m --until 1s 2>&1 | grep minecraft-console || echo "No recent events"

      - name: Deployment summary
        if: success()
        run: |
          {
            echo "## Console Deployment Successful! ðŸš€"
            echo ""
            echo "The web console has been deployed and is now live!"
            echo ""
            echo "**Docker Image:** ghcr.io/festas/minecraft-console:${{ needs.build-and-push.outputs.image_sha }}"
            echo "**Console URL:** https://mc.festas-builds.com/console"
            echo ""
            
            # Include post-deployment diagnostics summary if available
            if [ -d ./post-deploy-diagnostics ]; then
              SUMMARY_FILE=$(find ./post-deploy-diagnostics -name "deployment-summary.txt" | head -1)
              if [ -f "$SUMMARY_FILE" ]; then
                echo "### Post-Deployment Health Check"
                echo '```'
                cat "$SUMMARY_FILE"
                echo '```'
                echo ""
              fi
            fi
            
            echo "### Next Steps"
            echo "1. Ensure RCON is enabled in server.properties"
            echo "2. Update Caddyfile in Link-in-Bio repository (one-time setup)"
            echo "3. Access console at the URL above"
            echo ""
            echo "### Diagnostics Artifacts"
            echo "- Pre-deployment diagnostics uploaded as artifact"
            echo "- **Plugin install diagnostics uploaded as artifact** ðŸ“¦"
            echo "  - Includes install-errors.log for debugging plugin install issues"
            echo "  - Console logs related to plugin operations"
            echo "  - Backend data directory listing"
            echo "- Post-deployment diagnostics uploaded as artifact"
            echo "- Review artifacts for detailed health information"
          } >> "$GITHUB_STEP_SUMMARY"
