name: Deploy Console

on:
  push:
    branches:
      - main
    paths:
      - 'console/**'
      - '.github/workflows/deploy-console.yml'
  workflow_dispatch:

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image_sha: ${{ steps.image_sha.outputs.sha }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get short SHA
        id: image_sha
        run: echo "sha=$(git rev-parse --short HEAD)" >> "$GITHUB_OUTPUT"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: image=moby/buildkit:v0.12.5

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./console
          file: ./console/backend/Dockerfile
          push: true
          tags: |
            ghcr.io/festas/minecraft-console:${{ steps.image_sha.outputs.sha }}
            ghcr.io/festas/minecraft-console:latest

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          MISSING_SECRETS=()

          if [ -z "${{ secrets.GHCR_PAT }}" ]; then
            MISSING_SECRETS+=("GHCR_PAT")
          fi
          if [ -z "${{ secrets.CONSOLE_ADMIN_USER }}" ]; then
            MISSING_SECRETS+=("CONSOLE_ADMIN_USER")
          fi
          if [ -z "${{ secrets.CONSOLE_ADMIN_PASSWORD }}" ]; then
            MISSING_SECRETS+=("CONSOLE_ADMIN_PASSWORD")
          fi
          if [ -z "${{ secrets.RCON_PASSWORD }}" ]; then
            MISSING_SECRETS+=("RCON_PASSWORD")
          fi
          if [ -z "${{ secrets.SESSION_SECRET }}" ]; then
            MISSING_SECRETS+=("SESSION_SECRET")
          fi
          if [ -z "${{ secrets.CSRF_SECRET }}" ]; then
            MISSING_SECRETS+=("CSRF_SECRET")
          fi
          if [ -z "${{ secrets.REDIS_HOST }}" ]; then
            MISSING_SECRETS+=("REDIS_HOST")
          fi
          if [ -z "${{ secrets.REDIS_PORT }}" ]; then
            MISSING_SECRETS+=("REDIS_PORT")
          fi

          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "::error::Missing required secrets: ${MISSING_SECRETS[*]}"
            echo ""
            echo "Please add the following secrets to your repository:"
            echo "Settings > Secrets and variables > Actions > New repository secret"
            echo ""
            for secret in "${MISSING_SECRETS[@]}"; do
              echo "- $secret"
            done
            echo ""
            echo "See docs/admin/console-setup.md for detailed instructions."
            exit 1
          fi

          echo "âœ“ All required secrets are configured"

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Upload diagnostic scripts
        run: |
          echo "Uploading diagnostic scripts to server..."
          scp -i ~/.ssh/id_rsa scripts/diagnose-plugins.sh \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/home/deploy/minecraft-server/scripts/

          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
            "chmod +x /home/deploy/minecraft-server/scripts/diagnose-plugins.sh"

      - name: Pre-deployment diagnostics and auto-fix
        id: pre_deploy_check
        run: |
          echo "Running pre-deployment diagnostics..."

          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            cd /home/deploy/minecraft-server

            # Run diagnostics in fix mode
            ./scripts/diagnose-plugins.sh fix || true

            # Get the latest diagnostics directory
            DIAG_DIR=$(ls -td /tmp/plugin-diagnostics-* 2>/dev/null | head -1)

            if [ -n "$DIAG_DIR" ]; then
              # Count issues
              if [ -f "$DIAG_DIR/issues.log" ]; then
                ISSUE_COUNT=$(wc -l < "$DIAG_DIR/issues.log")
                echo "Pre-deployment found $ISSUE_COUNT issues"
              fi

              # Check for critical blocking issues
              if [ -f "$DIAG_DIR/manual-actions.log" ]; then
                if grep -qi "port.*missing\|bind.*missing" "$DIAG_DIR/manual-actions.log"; then
                  echo "::warning::Critical port/bind configuration issues detected"
                fi
              fi
            fi
          EOF

      - name: Download pre-deployment diagnostics
        run: |
          echo "Downloading pre-deployment diagnostics..."

          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            DIAG_DIR=$(ls -td /tmp/plugin-diagnostics-* 2>/dev/null | head -1)
            if [ -n "$DIAG_DIR" ]; then
              tar -czf /tmp/pre-deploy-diagnostics.tar.gz -C "$(dirname "$DIAG_DIR")" "$(basename "$DIAG_DIR")"
            fi
          EOF

          scp -i ~/.ssh/id_rsa \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/tmp/pre-deploy-diagnostics.tar.gz \
            ./pre-deploy-diagnostics.tar.gz || echo "No pre-deploy diagnostics available"

          if [ -f ./pre-deploy-diagnostics.tar.gz ]; then
            mkdir -p ./pre-deploy-diagnostics
            tar -xzf ./pre-deploy-diagnostics.tar.gz -C ./pre-deploy-diagnostics
          fi

      - name: Upload pre-deployment diagnostics artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: pre-deployment-diagnostics-${{ github.run_number }}
          path: pre-deploy-diagnostics/
          retention-days: 30
          if-no-files-found: warn

      - name: Validate required secrets
        uses: appleboy/ssh-action@v1.0.3
        env:
          IMAGE_SHA: ${{ needs.build-and-push.outputs.image_sha }}
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          GHCR_ACTOR: ${{ github.actor }}
          CONSOLE_ADMIN_USER: ${{ secrets.CONSOLE_ADMIN_USER }}
          CONSOLE_ADMIN_PASSWORD: ${{ secrets.CONSOLE_ADMIN_PASSWORD }}
          RCON_PASSWORD: ${{ secrets.RCON_PASSWORD }}
          SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
          CSRF_SECRET: ${{ secrets.CSRF_SECRET }}
          REDIS_HOST: ${{ secrets.REDIS_HOST }}
          REDIS_PORT: ${{ secrets.REDIS_PORT }}
          PLUGIN_ADMIN_TOKEN: ${{ secrets.PLUGIN_ADMIN_TOKEN }}
          DOMAIN: ${{ secrets.DOMAIN }}
          MINECRAFT_VERSION: ${{ secrets.MINECRAFT_VERSION }}
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          envs: IMAGE_SHA,GHCR_PAT,GHCR_ACTOR,CONSOLE_ADMIN_USER,CONSOLE_ADMIN_PASSWORD,RCON_PASSWORD,SESSION_SECRET,CSRF_SECRET,REDIS_HOST,REDIS_PORT,PLUGIN_ADMIN_TOKEN,DOMAIN,MINECRAFT_VERSION
          script: |
            set -e

            DEPLOY_DIR="/home/deploy/minecraft-console"
            MC_DIR="/home/deploy/minecraft-server"

            mkdir -p "$DEPLOY_DIR"
            cd "$DEPLOY_DIR"

            # Login to GHCR
            echo "$GHCR_PAT" | docker login ghcr.io -u "$GHCR_ACTOR" --password-stdin

            # Pull image
            docker pull "ghcr.io/festas/minecraft-console:${IMAGE_SHA}"

            # Create .env file from secrets (no leading whitespace)
            # Track missing optional secrets for deployment summary
            MISSING_OPTIONAL_SECRETS=()

            {
              printf 'ADMIN_USERNAME=%s\n' "${CONSOLE_ADMIN_USER}"
              printf 'ADMIN_PASSWORD=%s\n' "${CONSOLE_ADMIN_PASSWORD}"
              echo 'RCON_HOST=minecraft-server'
              echo 'RCON_PORT=25575'
              printf 'RCON_PASSWORD=%s\n' "${RCON_PASSWORD}"
              printf 'SESSION_SECRET=%s\n' "${SESSION_SECRET}"
              printf 'CSRF_SECRET=%s\n' "${CSRF_SECRET}"
              printf 'REDIS_HOST=%s\n' "${REDIS_HOST}"
              printf 'REDIS_PORT=%s\n' "${REDIS_PORT}"
              echo 'CONSOLE_PORT=3001'
              echo 'MC_CONTAINER_NAME=minecraft-server'
              echo 'MC_SERVER_DIR=/minecraft'
              echo 'NODE_ENV=production'
              # Allow cookies over HTTP for CI testing (secure: false)
              # Without this, session cookies won't be sent over HTTP and auth will fail
              echo 'COOKIE_SECURE=false'

              # Add optional secrets with fallbacks
              if [ -n "${PLUGIN_ADMIN_TOKEN}" ]; then
                printf 'PLUGIN_ADMIN_TOKEN=%s\n' "${PLUGIN_ADMIN_TOKEN}"
              else
                MISSING_OPTIONAL_SECRETS+=("PLUGIN_ADMIN_TOKEN")
              fi

              if [ -n "${DOMAIN}" ]; then
                printf 'DOMAIN=%s\n' "${DOMAIN}"
              else
                MISSING_OPTIONAL_SECRETS+=("DOMAIN")
                echo 'DOMAIN=mc.festas-builds.com'
              fi

              if [ -n "${MINECRAFT_VERSION}" ]; then
                printf 'MINECRAFT_VERSION=%s\n' "${MINECRAFT_VERSION}"
              else
                MISSING_OPTIONAL_SECRETS+=("MINECRAFT_VERSION")
                echo 'MINECRAFT_VERSION=Paper'
              fi
            } > .env
            chmod 600 .env

            # Write missing secrets report for deployment summary
            if [ ${#MISSING_OPTIONAL_SECRETS[@]} -gt 0 ]; then
              echo "MISSING_OPTIONAL_SECRETS=${MISSING_OPTIONAL_SECRETS[*]}" >> /tmp/deployment-status.txt
            fi

            # ================================================================
            # DOCKER COMPOSE GENERATION WITH AUTO-INJECTED REDIS SERVICE
            # ================================================================
            # This deployment workflow automatically injects the Redis service
            # and redis_data volume into the generated docker-compose.yml.
            #
            # Why Redis is auto-injected:
            # - Ensures reliable session persistence across restarts
            # - Guarantees CSRF token validity in all deployments
            # - Prevents session-related issues in CI/CD workflows
            #
            # The Redis service includes:
            # - Image: redis:7-alpine (recommended version)
            # - Health check: ensures Redis is ready before console starts
            # - Volume: redis_data for persistent session storage
            # - Network: caddy-network for service communication
            # ================================================================

            # Create docker-compose.yml with auto-injected Redis service
            # Redis is automatically included to ensure reliable session and CSRF support
            cat > docker-compose.yml <<EOF
            services:
              # Redis service for persistent session storage
              # Auto-injected to guarantee session/CSRF reliability in all deployments
              redis:
                image: redis:7-alpine
                container_name: minecraft-console-redis
                restart: unless-stopped
                command: redis-server --appendonly yes
                volumes:
                  - redis_data:/data
                networks:
                  - caddy-network
                healthcheck:
                  test: ["CMD", "redis-cli", "ping"]
                  interval: 10s
                  timeout: 3s
                  retries: 3
                  start_period: 10s

              minecraft-console:
                image: ghcr.io/festas/minecraft-console:${IMAGE_SHA}
                container_name: minecraft-console
                restart: unless-stopped
                ports:
                  - "3001:3001"
                extra_hosts:
                  - "host.docker.internal:host-gateway"
                environment:
                  - API_PORT=3001
                volumes:
                  - ./.env:/app/.env:ro
                  - ${MC_DIR}:/minecraft:rw
                  - /var/run/docker.sock:/var/run/docker.sock
                  - console_data:/app/data
                networks:
                  - caddy-network
                depends_on:
                  redis:
                    condition: service_healthy
                healthcheck:
                  test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3001/health"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
                  start_period: 30s

            volumes:
              console_data:
              redis_data:
                driver: local

            networks:
              caddy-network:
                external: true
            EOF

            # Create caddy-network if it doesn't exist
            docker network inspect caddy-network >/dev/null 2>&1 || docker network create caddy-network

            # Deploy
            docker compose up -d

            # Wait for healthy
            for i in {1..30}; do
              HEALTH=$(docker inspect --format='{{.State.Health.Status}}' minecraft-console 2>/dev/null || echo "starting")
              if [ "$HEALTH" = "healthy" ]; then
                echo "âœ“ Console is healthy"
                break
              fi
              sleep 2
            done

            echo "âœ“ Console deployed successfully!"
            echo "URL: https://mc.festas-builds.com/console"

      - name: Test plugin install functionality
        if: success()
        env:
          ADMIN_USER: ${{ secrets.CONSOLE_ADMIN_USER }}
          ADMIN_PASS: ${{ secrets.CONSOLE_ADMIN_PASSWORD }}
        run: |
          echo "Testing plugin install API..."

          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            set -e

            echo "=== Testing Plugin Install API ==="

            # Wait for console to be fully ready
            for i in {1..15}; do
              if curl -s http://localhost:3001/health > /dev/null 2>&1; then
                echo "âœ“ Console is ready"
                break
              fi
              echo "Waiting for console to be ready... ($i/15)"
              sleep 2
            done

            # Verify console is accessible
            HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3001/health || echo "000")
            if [ "$HEALTH_STATUS" != "200" ]; then
              echo "âœ— Console health check failed with status: $HEALTH_STATUS"
              exit 1
            fi

            # Create test install script that uses the API
            cat > /tmp/test-plugin-install.sh << 'SCRIPT'
            #!/bin/bash

            # Exit on error but continue to collect diagnostics
            TEST_FAILED=0

            # Test URL - use a small, well-known plugin for testing
            # Using a lightweight test plugin to avoid long downloads
            # Note: This URL is intentionally pinned to a specific version for test stability.
            # The test verifies the API works, not that this specific plugin version is available.
            # If this version becomes unavailable, update to a newer stable release.
            TEST_PLUGIN_URL="https://github.com/pl3xgaming/Pl3xMap/releases/download/v1.20.4-477/Pl3xMap-1.20.4-477.jar"
            TEST_PLUGIN_NAME="Pl3xMap"

            echo "Testing plugin install with URL: $TEST_PLUGIN_URL"
            echo ""

            # Read credentials from environment variables passed via SSH
            ADMIN_USERNAME="${ADMIN_USER:-admin}"
            ADMIN_PASSWORD="${ADMIN_PASS}"

            if [ -z "$ADMIN_PASSWORD" ]; then
              echo "âœ— ADMIN_PASSWORD not set"
              exit 1
            fi

            # Step 1: Login to get session
            echo "Step 1: Authenticating with API..."
            # Use stdin to avoid exposing credentials in process lists
            LOGIN_RESPONSE=$(printf '{"username":"%s","password":"%s"}' "$ADMIN_USERNAME" "$ADMIN_PASSWORD" | \
              curl -s -c /tmp/cookies.txt -w "\n%{http_code}" \
              -X POST http://localhost:3001/api/login \
              -H "Content-Type: application/json" \
              --data-binary @- 2>&1)

            LOGIN_STATUS=$(echo "$LOGIN_RESPONSE" | tail -1)
            LOGIN_BODY=$(echo "$LOGIN_RESPONSE" | sed '$d')

            echo "Login response status: $LOGIN_STATUS"
            if [ "$LOGIN_STATUS" = "200" ]; then
              echo "âœ“ Authentication successful"
              echo "Response: $LOGIN_BODY"
            else
              echo "âœ— Authentication failed"
              echo "Response: $LOGIN_BODY"
              TEST_FAILED=1
              exit 1
            fi
            echo ""

            # Step 1.5: Fetch CSRF token
            echo "Step 1.5: Fetching CSRF token..."
            CSRF_RESPONSE=$(curl -s -b /tmp/cookies.txt -c /tmp/cookies.txt -w "\n%{http_code}" \
              -X GET http://localhost:3001/api/csrf-token 2>&1)

            CSRF_STATUS=$(echo "$CSRF_RESPONSE" | tail -1)
            CSRF_BODY=$(echo "$CSRF_RESPONSE" | sed '$d')

            echo "CSRF token endpoint status: $CSRF_STATUS"
            if [ "$CSRF_STATUS" = "200" ]; then
              CSRF_TOKEN=$(echo "$CSRF_BODY" | jq -r '.csrfToken' 2>/dev/null)
              if [ -n "$CSRF_TOKEN" ] && [ "$CSRF_TOKEN" != "null" ]; then
                echo "âœ“ CSRF token obtained successfully"
                echo "CSRF token length: ${#CSRF_TOKEN} characters"

                # Check if CSRF cookie was saved
                echo "CSRF cookie check:"
                cat /tmp/cookies.txt | grep -v '^#' | grep csrf-token || echo "âš  No csrf-token cookie found"
              else
                echo "âœ— Failed to parse CSRF token from response"
                echo "Response: $CSRF_BODY"
                TEST_FAILED=1
                exit 1
              fi
            else
              echo "âœ— Failed to fetch CSRF token"
              echo "Response: $CSRF_BODY"
              TEST_FAILED=1
              exit 1
            fi
            echo ""

            # Capture plugins.json state before install
            echo "Step 2: Capturing plugins.json state before install..."
            if [ -f /home/deploy/minecraft-server/plugins.json ]; then
              cp /home/deploy/minecraft-server/plugins.json /tmp/plugins-before.json
              PLUGINS_COUNT_BEFORE=$(jq '.plugins | length' /tmp/plugins-before.json 2>/dev/null || echo "0")
              echo "Plugins before install: $PLUGINS_COUNT_BEFORE"
            else
              echo "âš  plugins.json not found, will be created"
              PLUGINS_COUNT_BEFORE=0
            fi
            echo ""

            # Step 3: Call plugin install API
            echo "Step 3: Calling plugin install API..."
            INSTALL_RESPONSE=$(curl -s -b /tmp/cookies.txt -w "\n%{http_code}" \
              -X POST http://localhost:3001/api/plugins/install \
              -H "Content-Type: application/json" \
              -H "CSRF-Token: $CSRF_TOKEN" \
              -d "{\"url\":\"$TEST_PLUGIN_URL\"}" 2>&1)

            INSTALL_STATUS=$(echo "$INSTALL_RESPONSE" | tail -1)
            INSTALL_BODY=$(echo "$INSTALL_RESPONSE" | sed '$d')

            echo "Install API response status: $INSTALL_STATUS"
            echo "Response body:"
            echo "$INSTALL_BODY" | jq '.' 2>/dev/null || echo "$INSTALL_BODY"
            echo ""

            # Step 4: Verify API returned success (200 or 201)
            if [ "$INSTALL_STATUS" = "200" ] || [ "$INSTALL_STATUS" = "201" ]; then
              echo "âœ“ API returned success status"
            else
              echo "âœ— API returned error status: $INSTALL_STATUS"

              # Check for CSRF or authentication errors
              if echo "$INSTALL_BODY" | grep -qi "csrf\|token"; then
                echo "âš  CSRF token error detected - the CSRF token may be invalid"
              elif echo "$INSTALL_BODY" | grep -qi "auth"; then
                echo "âš  Authentication error detected - the session may be invalid"
              fi

              TEST_FAILED=1
            fi

            # Check if response indicates success
            if echo "$INSTALL_BODY" | jq -e '.status == "installed" or .status == "conflict"' > /dev/null 2>&1; then
              INSTALL_RESULT_STATUS=$(echo "$INSTALL_BODY" | jq -r '.status')
              echo "âœ“ API response indicates status: $INSTALL_RESULT_STATUS"

              # If conflict detected, that's expected behavior after first run
              # The test verifies the API detects conflicts properly, which is part of correct behavior
              if [ "$INSTALL_RESULT_STATUS" = "conflict" ]; then
                echo "â„¹ Plugin already exists (conflict detected) - API correctly identified existing plugin"
                echo "This is expected behavior on subsequent runs and validates conflict detection works"
              fi
            else
              echo "âœ— API response does not indicate success"
              if echo "$INSTALL_BODY" | jq -e '.error' > /dev/null 2>&1; then
                ERROR_MSG=$(echo "$INSTALL_BODY" | jq -r '.error')
                echo "Error message: $ERROR_MSG"
              fi
              TEST_FAILED=1
            fi
            echo ""

            # Step 5: Verify plugins.json was updated
            echo "Step 5: Verifying plugins.json was updated..."
            if [ -f /home/deploy/minecraft-server/plugins.json ]; then
              echo "âœ“ plugins.json exists"

              # Validate JSON structure
              if jq empty /home/deploy/minecraft-server/plugins.json 2>/dev/null; then
                echo "âœ“ plugins.json is valid JSON"

                PLUGINS_COUNT_AFTER=$(jq '.plugins | length' /home/deploy/minecraft-server/plugins.json)
                echo "Plugins after install: $PLUGINS_COUNT_AFTER"

                # Check if our test plugin is in the list
                if jq -e ".plugins[] | select(.name == \"$TEST_PLUGIN_NAME\")" /home/deploy/minecraft-server/plugins.json > /dev/null 2>&1; then
                  echo "âœ“ Test plugin '$TEST_PLUGIN_NAME' found in plugins.json"
                  PLUGIN_INFO=$(jq ".plugins[] | select(.name == \"$TEST_PLUGIN_NAME\")" /home/deploy/minecraft-server/plugins.json)
                  echo "Plugin info:"
                  echo "$PLUGIN_INFO" | jq '.'
                else
                  echo "âš  Test plugin '$TEST_PLUGIN_NAME' not found in plugins.json (may already exist or conflict)"
                fi
              else
                echo "âœ— plugins.json is invalid JSON"
                TEST_FAILED=1
              fi
            else
              echo "âœ— plugins.json does not exist after install"
              TEST_FAILED=1
            fi
            echo ""

            # Step 6: Verify JAR file exists in plugins directory
            echo "Step 6: Verifying JAR file exists in plugins directory..."
            if [ -d /home/deploy/minecraft-server/plugins ]; then
              echo "âœ“ Plugins directory exists"

              # Look for the test plugin JAR file
              if ls /home/deploy/minecraft-server/plugins/ | grep -i "$TEST_PLUGIN_NAME" > /dev/null 2>&1; then
                echo "âœ“ Test plugin JAR file found in plugins directory"
                ls -lh /home/deploy/minecraft-server/plugins/ | grep -i "$TEST_PLUGIN_NAME"
              else
                echo "âš  Test plugin JAR file not found (may already exist with different name or conflict)"
                echo "Files in plugins directory:"
                ls -lh /home/deploy/minecraft-server/plugins/ | head -10
              fi
            else
              echo "âœ— Plugins directory does not exist"
              TEST_FAILED=1
            fi
            echo ""

            # Step 7: Check install-errors.log
            echo "Step 7: Checking install-errors.log..."
            if docker exec minecraft-console test -f /app/data/install-errors.log 2>/dev/null; then
              echo "âœ“ install-errors.log exists"
              echo "Recent entries:"
              docker exec minecraft-console tail -20 /app/data/install-errors.log 2>/dev/null || echo "Could not read log"
            else
              echo "â„¹ install-errors.log not found (may not have any errors)"
            fi
            echo ""

            # Summary
            echo "================================================"
            echo "PLUGIN INSTALL API TEST SUMMARY"
            echo "================================================"
            if [ $TEST_FAILED -eq 0 ]; then
              echo "âœ“ ALL TESTS PASSED"
              echo "Plugin install API is working correctly!"
              exit 0
            else
              echo "âœ— SOME TESTS FAILED"
              echo "Review the output above for details"
              exit 1
            fi
            SCRIPT

            chmod +x /tmp/test-plugin-install.sh

            # Pass credentials through environment
            ADMIN_USER="$ADMIN_USER" ADMIN_PASS="$ADMIN_PASS" /tmp/test-plugin-install.sh
            TEST_EXIT_CODE=$?

            # Collect install-errors.log regardless of test result
            echo ""
            echo "=== Collecting install-errors.log ==="
            docker exec minecraft-console cat /app/data/install-errors.log 2>/dev/null || echo "No install-errors.log found"

            # Exit with test result
            exit $TEST_EXIT_CODE
          EOF

      - name: Download plugin install logs
        if: always()
        run: |
          echo "Downloading plugin install logs and diagnostics..."

          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            # Create a directory for plugin install diagnostics
            mkdir -p /tmp/plugin-install-diagnostics

            # Copy install-errors.log if it exists
            docker exec minecraft-console cat /app/data/install-errors.log > /tmp/plugin-install-diagnostics/install-errors.log 2>/dev/null || echo "No install-errors.log found" > /tmp/plugin-install-diagnostics/install-errors.log

            # Get recent console logs related to plugin installs
            docker logs minecraft-console --tail 200 2>&1 | grep -i "plugin" > /tmp/plugin-install-diagnostics/console-plugin-logs.txt || echo "No plugin-related logs found"

            # Get full recent console logs
            docker logs minecraft-console --tail 500 > /tmp/plugin-install-diagnostics/console-recent.log 2>&1

            # Collect backend data directory info
            docker exec minecraft-console ls -laR /app/data/ > /tmp/plugin-install-diagnostics/backend-data-listing.txt 2>/dev/null || echo "Could not list backend data directory"

            # Collect plugin-history.json if it exists
            docker exec minecraft-console cat /app/data/plugin-history.json > /tmp/plugin-install-diagnostics/plugin-history.json 2>/dev/null || echo "No plugin history found"

            # IMPORTANT: Collect plugins.json for verification
            if [ -f /home/deploy/minecraft-server/plugins.json ]; then
              cp /home/deploy/minecraft-server/plugins.json /tmp/plugin-install-diagnostics/plugins.json
              echo "âœ“ Captured plugins.json"
            else
              echo "âš  plugins.json not found" > /tmp/plugin-install-diagnostics/plugins.json
            fi

            # Collect before/after snapshots if they exist
            if [ -f /tmp/plugins-before.json ]; then
              cp /tmp/plugins-before.json /tmp/plugin-install-diagnostics/plugins-before.json
              echo "âœ“ Captured plugins-before.json"
            fi

            # List plugins directory
            if [ -d /home/deploy/minecraft-server/plugins ]; then
              ls -lah /home/deploy/minecraft-server/plugins/ > /tmp/plugin-install-diagnostics/plugins-directory-listing.txt 2>&1
              echo "âœ“ Captured plugins directory listing"
            fi

            # Create tarball
            tar -czf /tmp/plugin-install-diagnostics.tar.gz -C /tmp plugin-install-diagnostics/
          EOF

          # Download the diagnostics
          scp -i ~/.ssh/id_rsa \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/tmp/plugin-install-diagnostics.tar.gz \
            ./plugin-install-diagnostics.tar.gz || echo "No plugin install diagnostics available"

          if [ -f ./plugin-install-diagnostics.tar.gz ]; then
            mkdir -p ./plugin-install-diagnostics
            tar -xzf ./plugin-install-diagnostics.tar.gz -C ./plugin-install-diagnostics

            # Display key diagnostics files
            echo ""
            echo "=== install-errors.log content ==="
            if [ -f ./plugin-install-diagnostics/plugin-install-diagnostics/install-errors.log ]; then
              cat ./plugin-install-diagnostics/plugin-install-diagnostics/install-errors.log
            else
              echo "No install-errors.log found"
            fi

            echo ""
            echo "=== plugins.json content ==="
            if [ -f ./plugin-install-diagnostics/plugin-install-diagnostics/plugins.json ]; then
              cat ./plugin-install-diagnostics/plugin-install-diagnostics/plugins.json | jq '.' || cat ./plugin-install-diagnostics/plugin-install-diagnostics/plugins.json
            else
              echo "No plugins.json found"
            fi

            echo ""
            echo "=== Plugins directory listing ==="
            if [ -f ./plugin-install-diagnostics/plugin-install-diagnostics/plugins-directory-listing.txt ]; then
              cat ./plugin-install-diagnostics/plugin-install-diagnostics/plugins-directory-listing.txt
            else
              echo "No directory listing found"
            fi
          fi

      - name: Upload plugin install diagnostics artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: plugin-install-diagnostics-${{ github.run_number }}
          path: plugin-install-diagnostics/
          retention-days: 30
          if-no-files-found: warn

      - name: Post-deployment diagnostics and auto-fix
        if: success()
        run: |
          echo "Running post-deployment diagnostics..."

          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            cd /home/deploy/minecraft-server

            # Run diagnostics in fix mode with auto-restart enabled
            AUTO_RESTART=true ./scripts/diagnose-plugins.sh fix || true

            # Get the latest diagnostics directory
            DIAG_DIR=$(ls -td /tmp/plugin-diagnostics-* 2>/dev/null | head -1)

            if [ -n "$DIAG_DIR" ]; then
              echo "Post-deployment diagnostics completed"

              # Display summary
              if [ -f "$DIAG_DIR/deployment-summary.txt" ]; then
                echo "=== Deployment Summary ==="
                cat "$DIAG_DIR/deployment-summary.txt"
              fi

              # Check if any issues remain
              if [ -f "$DIAG_DIR/manual-actions.log" ]; then
                MANUAL_COUNT=$(wc -l < "$DIAG_DIR/manual-actions.log")
                if [ "$MANUAL_COUNT" -gt 0 ]; then
                  echo "::warning::$MANUAL_COUNT manual actions still required after deployment"
                fi
              fi
            fi
          EOF

      - name: Download post-deployment diagnostics
        if: success()
        run: |
          echo "Downloading post-deployment diagnostics..."

          ssh -i ~/.ssh/id_rsa ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            DIAG_DIR=$(ls -td /tmp/plugin-diagnostics-* 2>/dev/null | head -1)
            if [ -n "$DIAG_DIR" ]; then
              tar -czf /tmp/post-deploy-diagnostics.tar.gz -C "$(dirname "$DIAG_DIR")" "$(basename "$DIAG_DIR")"
            fi
          EOF

          scp -i ~/.ssh/id_rsa \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/tmp/post-deploy-diagnostics.tar.gz \
            ./post-deploy-diagnostics.tar.gz || echo "No post-deploy diagnostics available"

          if [ -f ./post-deploy-diagnostics.tar.gz ]; then
            mkdir -p ./post-deploy-diagnostics
            tar -xzf ./post-deploy-diagnostics.tar.gz -C ./post-deploy-diagnostics
          fi

      - name: Upload post-deployment diagnostics artifact
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: post-deployment-diagnostics-${{ github.run_number }}
          path: post-deploy-diagnostics/
          retention-days: 30
          if-no-files-found: warn

      - name: Handle deployment failure
        if: failure()
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            echo "=== Deployment Failed - Diagnostics ==="
            echo ""
            echo "=== Container Status ==="
            docker ps -a | grep minecraft-console || echo "Container not found"
            echo ""
            echo "=== Container Logs ==="
            docker logs minecraft-console --tail=100 2>&1 || echo "No logs available"
            echo ""
            echo "=== Recent Docker Events ==="
            docker events --since 5m --until 1s 2>&1 | grep minecraft-console || echo "No recent events"

      - name: Download deployment status
        if: success()
        run: |
          echo "Downloading deployment status..."

          scp -i ~/.ssh/id_rsa \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/tmp/deployment-status.txt \
            ./deployment-status.txt 2>/dev/null || echo "No deployment status file found"

      - name: Deployment summary
        if: success()
        run: |
          {
            echo "## Console Deployment Successful! ðŸš€"
            echo ""
            echo "The web console has been deployed and is now live!"
            echo ""
            echo "**Docker Image:** ghcr.io/festas/minecraft-console:${{ needs.build-and-push.outputs.image_sha }}"
            echo "**Console URL:** https://mc.festas-builds.com/console"
            echo ""

            # Check for missing optional secrets
            if [ -f ./deployment-status.txt ]; then
              MISSING_SECRETS=$(grep "MISSING_OPTIONAL_SECRETS=" ./deployment-status.txt | cut -d= -f2)
              if [ -n "$MISSING_SECRETS" ]; then
                echo "### âš ï¸ Missing Optional Secrets"
                echo ""
                echo "The following optional secrets were not configured and fallback values were used:"
                echo ""
                for secret in $MISSING_SECRETS; do
                  echo "- **$secret**"
                done
                echo ""
                echo "These secrets enhance functionality but are not required for basic operation."
                echo "Add them in Settings > Secrets and variables > Actions for full features."
                echo ""
              fi
            fi

            # Include post-deployment diagnostics summary if available
            if [ -d ./post-deploy-diagnostics ]; then
              SUMMARY_FILE=$(find ./post-deploy-diagnostics -name "deployment-summary.txt" | head -1)
              if [ -f "$SUMMARY_FILE" ]; then
                echo "### Post-Deployment Health Check"
                echo '```'
                cat "$SUMMARY_FILE"
                echo '```'
                echo ""
              fi
            fi

            echo "### Next Steps"
            echo "1. Ensure RCON is enabled in server.properties"
            echo "2. Update Caddyfile in Link-in-Bio repository (one-time setup)"
            echo "3. Access console at the URL above"
            echo ""
            echo "### Diagnostics Artifacts"
            echo "- Pre-deployment diagnostics uploaded as artifact"
            echo "- **Plugin install diagnostics uploaded as artifact** ðŸ“¦"
            echo "  - Includes install-errors.log for debugging plugin install issues"
            echo "  - Console logs related to plugin operations"
            echo "  - Backend data directory listing"
            echo "- Post-deployment diagnostics uploaded as artifact"
            echo "- Review artifacts for detailed health information"
          } >> "$GITHUB_STEP_SUMMARY"
